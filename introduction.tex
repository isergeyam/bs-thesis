Cегодня, все больше отраслей компьютерных технологий нуждаются в формальной верификации. В первую очередь, в этот список входят программы,
связанные с транспортом, коммуникацией, медициной, компьютерной безопасностью, криптографией и банковским делом. 
В этих критических сферах,
последствия отсутствия формальной верификации в некоторых проектах привели к очень плачевным последствиям \cite{horror}.
Фундаментальным отличием формальной верификации от классического тестирования ПО заключается в том, что, в то время как классическое
тестирование проверяет систему лишь на каком-то подмножестве возможных входов, формальная верификация ПО позволяет утвеждать о
корректности системы на всех возможных входах. Такого вида гарантии конечно же дают несравнимо большую уверенность в корректности
работы данного ПО, даже учитвая то, что остальные части системы, такие как компилятор, аппаратное обеспечение, и,
в конце концов, само ПО, используемое для верификации, могут дать сбои. Ибо мы таким образом убеждаемся в том, что сам код, который
является частью ПО, ошибок не содержит. Можно привести в пример много проектов, использующих формальную верификацию для довольно сложных
систем. Например, в верификации компиляторов -- проект Jinja \cite{KleinN-TCS,KleinN-ACM}, проект Verisoft
\cite{Strecker_compilerverification,Leinenbach}, а также проект CompCert \cite{Xavier,CompCert}.
В блокчейне -- проект Scilla \cite{sergey2018scilla}. Таким образом, мы можем убедиться в том, что формальная верификация ПО
и вправду очень востребованна. 
\par
Но наряду с верификацией программ, также встает вопрос верификации асимптотики применяемого алгоритма. Действительно, довольно часто
мы хотим убедиться не только в том, что алгоритм корректен, но также и в том, что его асимптотика соответствует нашим ожиданиям.
На самом деле, баги, связанные с асимтотикой алгоритма, могут возникать довольно часто только для конкретных входов, что делает
классический подход тестирования неприемлемым для их отыскания. например, рассмотрим следующую реализацию бинарного поиска
(на языке Python).
\pagebreak
\begin{figure}[H]
  \caption{Проблемный бинарный поиск}
  \label{code:bsearch}
  \begin{minted}{python}
# Requires t to be a sorted array of integers.
# Returns k such that i <= k < j and t[k] = v
# or -1 if there is no such k.
def bsearch(t, v, i, j):
    if j <= i:
        return -1
    k = i + (j-i) // 2
    if v == t[k]:
        return k
    elif v < t[k]:
        return bsearch(t, v, i, k)
    return bsearch(t, v, i+1, j)
\end{minted}
\end{figure}
Проблема этого кода состоит в том, что при попадании в правую часть списка, вместо того, чтобы рассматривать интервал $[k+1;j)$, мы
рассматриваем интервал \\
$[i+1;j)$. Конечно, сам алгоритм корректно реализует бинарный поиск, но асимптотика при вводе, скажем, 
последнего элемента массива, превращается из логарифмической в линейную. На этом примере хорошо видно, что даже формальной верификации
алгоритма и классического тестирования его на проверку асимптотики работы не всегда гарантирует нам корректность этой самой асимптотики. 
В связи с этим, возникает потребность в том, чтобы иметь также возможность формально верифицировать не только корректность алгоритма, но
и его асимптотику. 
\par
В данной работе мы покажем, как формальная верификация алгоритмов и их асимптотик может быть реализована с помощью Сепарационной Логики
с временными кредитами \cite{base_article}. С помощью этой теории, мы формально верифицируем алгоритм нахождения наибольшей общей подпоследовательности. 