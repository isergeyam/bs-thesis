Cегодня, все больше отраслей компьютерных технологий нуждаются в формальной верификации. В первую очередь, в этот список входят программы,
связанные с транспортом, коммуникацией, медициной, компьютерной безопасностью, криптографией и банковским делом.
В этих критических сферах,
последствия отсутствия формальной верификации в некоторых проектах привели к очень плачевным последствиям. Например, миссия НАСА Mars Climate Orbiter
сорвалась из-за довольно банальной ошибки в софте \cite{horror}. Есть и другие, гораздо более пугающие примеры \cite{horror}.
Фундаментальным отличием формальной верификации от классического тестирования ПО заключается в том, что, в то время как классическое
тестирование проверяет систему лишь на каком-то подмножестве возможных входов, формальная верификация ПО позволяет утвеждать о
корректности системы на всех возможных входах. Такого вида гарантии конечно же дают несравнимо большую уверенность в корректности
работы данного ПО, даже учитвая то, что остальные части системы, такие как компилятор, аппаратное обеспечение, и,
в конце концов, само ПО, используемое для верификации, могут дать сбои. Ибо мы таким образом убеждаемся в том, что сам код, который
является частью ПО, ошибок не содержит. Можно привести в пример много проектов, использующих формальную верификацию для довольно сложных
систем. Например, в верификации компиляторов -- проект Jinja \cite{KleinN-TCS,KleinN-ACM}, проект Verisoft
\cite{Strecker_compilerverification,Leinenbach}, а также проект CompCert \cite{Xavier,CompCert}.
В блокчейне -- проект Scilla \cite{sergey2018scilla}. Таким образом, мы можем убедиться в том, что формальная верификация ПО
и вправду очень востребованна.
\par
Одним из основных инструментов верификации программ является интерактивное программное средство доказательства теорем Coq
\cite{the_coq_development_team_2021_4501022}. Coq представляет из себя богатый формальный язык, основанный на
исчислении индуктивных конструкций(Calculus of Inductive Constructions, CIC) \cite{CIC} -- формальной системе, которая способна
представлять как функциональные программы в стиле ML \cite{ML-lang}, так и доказательства в логике высшего порядка. CIC в свою
очередь основан на чистой системе типов(Pure type system \cite{PTS}) -- исчислении конструкций (The Calculus of Constructions) \cite{CalculusOfConstructions}.
Coq, как и любое другое средство доказательств, основанное на теории типов, использует для представления утверждений и доказательств
Соответствие Карри — Ховарда \cite{CurryHowardIsom} -- изоморфизм, сопоставляющий логическому высказыванию тип, а доказательству данного утверждения
-- терм данного типа. Используя это соответствие, задача проверки доказательства сводится к задаче проверки типа выражения. Эта задача
решается специальном модулем Coq, ядром -- отностительно небольшой программой, очень тщательно написанной, т.к. это самая важная часть
системы -- допущенная в ней ошибка может привести к доказательствам неверных утверждений.
Для формализации внутри Coq математических концепций и спецификации ПО Coq предоставляет богатый язык команд Vernacular.
С помощью него можно вводить новые обозначения, отношения, порядки, предикаты, и т.д.
\par
Для построения фреймворка для верификации императивных программ, нужно каким-то образом инкорпорировать в этот фреймвор состояние программы,
а также создать инструменты для рассуждения о том, как программы влияют на эти самые состояния. Стандартным подходом для данной задачи
является логика Хоара \cite{Hoare}. Логика Хоара представляет из себя формальную систему, которая позволяет рассуждать о корректности
императивных программ. Основным инструментом логики Хоара является тройка Хоара $\{P\}C\{Q\}$, где P и Q -- это предикаты на множестве состояний,
а C -- это некоторая поседовательность команд. Вывод данной тройки в логике Хоара означает, что если текущее состояние удовлетворяет
утверждению $P$, то после выполнения на нем программы $C$ она будет удовлетворять утверждению $Q$. Правила вывода в логике Хоара
строятся довольно естественно. Например, ясно, что пустая команда ничего не делает с состоянием, поэтому можно добавить правило вывода
$\{P\}\textbf{skip}\{P\}$.
\par
Логиках Хоара является отличным инструментом для рассуждения о программах, но она не может нам помочь в случае, когда нам нужно иметь
общее состояние в программе(то есть указатели на те же участки памяти). Формально говоря, состояние в логике Хоара -- это всего лишь
отображение переменных в их значения, но в реальных языках программирования присутствуют также и указатели, которые хранят не значение,
а ссылку на него. С такого вида состояниями логиха Хоара работать не позволяет. Например, пусть утверждение имеет вид
$x \mapsto 3 \land y \mapsto 3$, то есть говорит о двух указателях, которые указывают на ячейку с числом $3$ внутри. Из этого утверждения
никак не понять, является ли ячейка, на которую указывают $x$ и $y$, одной и той же, или же это разные ячейки, у которых просто
совпадают значения? Очевидно, что от ответа на этот вопрос зависит эффект, который произведет, скажем, команда $\{*x = 4\}$ -- присваивание
ячейки, на которую указывает $x$, значение 3.
\par
Для рассуждения подобного вида нам приходит на помощь Сепарационная Логика \cite{SepLogic}. Это расширение логики Хоара, которое
вводит дополнительную логическую операцию $P \ast Q$ -- логическую конъюкцию. Выражение $P \ast Q$ утверждает, что текущее состояние
может быть разделено на два непересекающихся в адресном пространстве состояния, каждое из которых удовлетворяет $P$ и $Q$ соответственно.
Данная логика также вводит одно очень важное правило вывода, называемое правилом фрейма(frame rule)
$$
    \frac{\{P\} C\{Q\}}{\{P * R\} C\{Q * R\}}
$$
Это правило вывода позволяет обобщать локальные рассуждение о маленьком состоянии на большее состояние. В данной логике предикат
$x \mapsto 3 \ast y \mapsto 3$ уже имеет четкий смысл. Библиотека CFML \cite{CFML} формализует Сепарационную Логику в Coq для верификации
программ на OCaml.
\par
Но наряду с верификацией программ, также встает вопрос верификации асимптотики применяемого алгоритма. Действительно, довольно часто
мы хотим убедиться не только в том, что алгоритм корректен, но также и в том, что его асимптотика соответствует нашим ожиданиям.
На самом деле, баги, связанные с асимтотикой алгоритма, могут возникать довольно часто только для конкретных входов, что делает
классический подход тестирования неприемлемым для их отыскания. например, рассмотрим следующую реализацию бинарного поиска
(на языке Python).
\pagebreak
\begin{figure}[H]
    \caption{Проблемный бинарный поиск}
    \label{code:bsearch}
    \begin{minted}{python}
# Requires t to be a sorted array of integers.
# Returns k such that i <= k < j and t[k] = v
# or -1 if there is no such k.
def bsearch(t, v, i, j):
    if j <= i:
        return -1
    k = i + (j-i) // 2
    if v == t[k]:
        return k
    elif v < t[k]:
        return bsearch(t, v, i, k)
    return bsearch(t, v, i+1, j)
\end{minted}
\end{figure}
Проблема этого кода состоит в том, что при попадании в правую часть списка, вместо того, чтобы рассматривать интервал $[k+1;j)$, мы
рассматриваем интервал \\
$[i+1;j)$. Конечно, сам алгоритм корректно реализует бинарный поиск, и его корректность можно формально доказать, 
но асимптотика при вводе, скажем, последнего элемента массива, превращается из логарифмической в линейную. 
На этом примере хорошо видно, что даже формальной верификации алгоритма и классического тестирования его на проверку 
асимптотики работы не всегда гарантирует нам корректность этой самой асимптотики.
В связи с этим, возникает потребность в том, чтобы иметь также возможность формально верифицировать не только корректность алгоритма, но
и его асимптотику.
\par
В данной работе мы покажем, как формальная верификация алгоритмов и их асимптотик может быть реализована с помощью Сепарационной Логики
с временными кредитами \cite{base_article}. С помощью этой теории, мы формально верифицируем алгоритм нахождения наибольшей общей подпоследовательности
в системе интерактивных доказательств Coq \cite{the_coq_development_team_2021_4501022}.