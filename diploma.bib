@misc{horror,
  author = {N. Dershowitz},
  title  = {SOFTWARE HORROR STORIES},
  url    = {https://www.cs.tau.ac.il/~nachumd/verify/horror.html}
} 

@article{KleinN-TCS,
  author  = {Gerwin Klein and Tobias Nipkow},
  title   = {Verified Bytecode Verifiers},
  journal = {TCS},
  year    = 2003,
  volume  = 298,
  pages   = {583--626}
}

@article{KleinN-ACM,
  author     = {Klein, Gerwin and Nipkow, Tobias},
  title      = {A Machine-Checked Model for a Java-like Language, Virtual Machine, and Compiler},
  year       = {2006},
  issue_date = {July 2006},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {28},
  number     = {4},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/1146809.1146811},
  doi        = {10.1145/1146809.1146811},
  abstract   = {We introduce Jinja, a Java-like programming language with a formal semantics designed to exhibit core features of the Java language architecture. Jinja is a compromise between the realism of the language and the tractability and clarity of its formal semantics. The following aspects are formalised: a big and a small step operational semantics for Jinja and a proof of their equivalence, a type system and a definite initialisation analysis, a type safety proof of the small step semantics, a virtual machine (JVM), its operational semantics and its type system, a type safety proof for the JVM; a bytecode verifier, that is, a data flow analyser for the JVM, a correctness proof of the bytecode verifier with respect to the type system, and a compiler and a proof that it preserves semantics and well-typedness. The emphasis of this work is not on particular language features but on providing a unified model of the source language, the virtual machine, and the compiler. The whole development has been carried out in the theorem prover Isabelle/HOL.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = jul,
  pages      = {619–695},
  numpages   = {77},
  keywords   = {Java, operational semantics, theorem proving}
}

@misc{Strecker_compilerverification,
  author = {Martin Strecker},
  title  = {Compiler Verification for C0 (intermediate report)},
  year   = {}
}

@inproceedings{Leinenbach,
  author    = {Leinenbach, Dirk and Paul, Wolfgang and Petrova, Elena},
  title     = {Towards the Formal Verification of a C0 Compiler: Code Generation and Implementation Correctnes},
  year      = {2005},
  isbn      = {0769524354},
  publisher = {IEEE Computer Society},
  address   = {USA},
  url       = {https://doi.org/10.1109/SEFM.2005.51},
  doi       = {10.1109/SEFM.2005.51},
  abstract  = {In the spirit of the famous CLI stack project [2] the Verisoft project [31] aims at the pervasive verification of entire computer systems including hardware, system software, compiler, and communicating applications, with a special focus on industrial applications. The main programming language used in the Verisoft project is C0 (a subset of C which is similar to MISRA C [20]). This paper reports on (i) an operational small steps semantics for C0 which is formalized in Isabelle/HOL [25], (ii) the formal specification of a compiler from C0 to the DLX machine language [14, 23] in Isabelle/HOL, (iii) a paper and pencil correctness proof for this compiler and the status of the formal verification effort for this proof, and (iv) the implementation of the compiler in C0 and a formal proof in Isabelle/HOL that the implementation produces the same code as the specification.},
  booktitle = {Proceedings of the Third IEEE International Conference on Software Engineering and Formal Methods},
  pages     = {2–12},
  numpages  = {11},
  series    = {SEFM '05}
}

@inproceedings{10.1145/1111037.1111042,
  author    = {Leroy, Xavier},
  title     = {Formal Certification of a Compiler Back-End or: Programming a Compiler with a Proof Assistant},
  year      = {2006},
  isbn      = {1595930272},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1111037.1111042},
  doi       = {10.1145/1111037.1111042},
  abstract  = {This paper reports on the development and formal certification (proof of semantic preservation) of a compiler from Cminor (a C-like imperative language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a certified compiler is useful in the context of formal methods applied to the certification of critical software: the certification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
  booktitle = {Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {42–54},
  numpages  = {13},
  keywords  = {semantic preservation, certified compilation, the Coq theorem prover, program proof, compiler transformations and optimizations},
  location  = {Charleston, South Carolina, USA},
  series    = {POPL '06}
}

@article{Xavier,
  author     = {Leroy, Xavier},
  title      = {Formal Certification of a Compiler Back-End or: Programming a Compiler with a Proof Assistant},
  year       = {2006},
  issue_date = {January 2006},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {41},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1111320.1111042},
  doi        = {10.1145/1111320.1111042},
  abstract   = {This paper reports on the development and formal certification (proof of semantic preservation) of a compiler from Cminor (a C-like imperative language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a certified compiler is useful in the context of formal methods applied to the certification of critical software: the certification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
  journal    = {SIGPLAN Not.},
  month      = jan,
  pages      = {42–54},
  numpages   = {13},
  keywords   = {program proof, the Coq theorem prover, certified compilation, semantic preservation, compiler transformations and optimizations}
}

@misc{CompCert,
  author = {Xavier Leroy et al.},
  title  = { The CompCert verified compiler.},
  url    = {http://compcert.inria.fr/}
}

@misc{sergey2018scilla,
  title         = {Scilla: a Smart Contract Intermediate-Level LAnguage},
  author        = {Ilya Sergey and Amrit Kumar and Aquinas Hobor},
  year          = {2018},
  eprint        = {1801.00687},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL}
}

@inproceedings{base_article,
  author    = {Gu{\'e}neau, Arma{\"e}l
and Chargu{\'e}raud, Arthur
and Pottier, Fran{\c{c}}ois},
  editor    = {Ahmed, Amal},
  title     = {A Fistful of Dollars: Formalizing Asymptotic Complexity Claims via Deductive Program Verification},
  booktitle = {Programming Languages and Systems},
  year      = {2018},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {533--560},
  abstract  = {We present a framework for simultaneously verifying the functional correctness and the worst-case asymptotic time complexity of higher-order imperative programs. We build on top of Separation Logic with Time Credits, embedded in an interactive proof assistant. We formalize the O notation, which is key to enabling modular specifications and proofs. We cover the subtleties of the multivariate case, where the complexity of a program fragment depends on multiple parameters. We propose a way of integrating complexity bounds into specifications, present lemmas and tactics that support a natural reasoning style, and illustrate their use with a collection of examples.},
  isbn      = {978-3-319-89884-1}
}

@software{the_coq_development_team_2021_4501022,
  author    = {The Coq Development Team},
  title     = {The Coq Proof Assistant},
  month     = jan,
  year      = 2021,
  publisher = {Zenodo},
  version   = {8.13},
  doi       = {10.5281/zenodo.4501022},
  url       = {https://doi.org/10.5281/zenodo.4501022}
}

@misc{rojas2015tutorial,
  title         = {A Tutorial Introduction to the Lambda Calculus},
  author        = {Raul Rojas},
  year          = {2015},
  eprint        = {1503.09060},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LO}
}

@article{Church01,
  issn      = {0003486X},
  url       = {http://www.jstor.org/stable/1968337},
  author    = {Alonzo Church},
  journal   = {Annals of Mathematics},
  number    = {2},
  pages     = {346--366},
  publisher = {Annals of Mathematics},
  title     = {A Set of Postulates for the Foundation of Logic},
  volume    = {33},
  year      = {1932}
}

@misc{Miller_ahistorical,
  author = {Justin T Miller},
  title  = {A Historical Account of Set-Theoretic Antinomies Caused by the Axiom of Abstraction},
  year   = {}
}

@article{Kleene01,
  issn      = {0003486X},
  url       = {http://www.jstor.org/stable/1968646},
  author    = {S. C. Kleene and J. B. Rosser},
  journal   = {Annals of Mathematics},
  number    = {3},
  pages     = {630--636},
  publisher = {Annals of Mathematics},
  title     = {The Inconsistency of Certain Formal Logics},
  volume    = {36},
  year      = {1935}
}

@article{Church02,
  issn      = {00029327, 10806377},
  url       = {http://www.jstor.org/stable/2371045},
  author    = {Alonzo Church},
  journal   = {American Journal of Mathematics},
  number    = {2},
  pages     = {345--363},
  publisher = {Johns Hopkins University Press},
  title     = {An Unsolvable Problem of Elementary Number Theory},
  volume    = {58},
  year      = {1936}
}

@article{Church03,
  issn      = {00224812},
  url       = {http://www.jstor.org/stable/2266170},
  author    = {Alonzo Church},
  journal   = {The Journal of Symbolic Logic},
  number    = {2},
  pages     = {56--68},
  publisher = {Association for Symbolic Logic},
  title     = {A Formulation of the Simple Theory of Types},
  volume    = {5},
  year      = {1940}
}

@article{MR1501858,
  author   = {Church, Alonzo and Rosser, J. B.},
  title    = {Some properties of conversion},
  journal  = {Trans. Amer. Math. Soc.},
  fjournal = {Transactions of the American Mathematical Society},
  volume   = {39},
  year     = {1936},
  number   = {3},
  pages    = {472--482},
  issn     = {0002-9947},
  mrclass  = {03B40},
  mrnumber = {1501858},
  doi      = {10.2307/1989762},
  url      = {https://doi.org/10.2307/1989762}
}

@article{engeler_1984,
  title     = {H. P. Barendregt. The lambda calculus. Its syntax and semantics. Studies in logic and foundations of mathematics, vol. 103. North-Holland Publishing Company, Amsterdam, New York, and Oxford, 1981, xiv 615 pp.},
  volume    = {49},
  doi       = {10.2307/2274112},
  number    = {1},
  journal   = {Journal of Symbolic Logic},
  publisher = {Cambridge University Press},
  author    = {Engeler, E.},
  year      = {1984},
  pages     = {301–303}
}

@article{Turing01,
  issn      = {00224812},
  url       = {http://www.jstor.org/stable/2268280},
  author    = {A. M. Turing},
  journal   = {The Journal of Symbolic Logic},
  number    = {4},
  pages     = {153--163},
  publisher = {[Association for Symbolic Logic, Cambridge University Press]},
  title     = {Computability and \textlambda-Definability},
  volume    = {2},
  year      = {1937}
}

@article{Tait01,
  issn      = {00224812},
  url       = {http://www.jstor.org/stable/2271658},
  author    = {W. W. Tait},
  journal   = {The Journal of Symbolic Logic},
  number    = {2},
  pages     = {198--212},
  publisher = {Association for Symbolic Logic},
  title     = {Intensional Interpretations of Functionals of Finite Type I},
  volume    = {32},
  year      = {1967}
}

@article{ocaml,
  title   = {The OCaml system: Documentation and user’s manual},
  author  = {Leroy, Xavier and Doligez, Damien and Frisch, Alain and Garrigue, Jacques and R{\'e}my, Didier and Vouillon, J{\'e}r{\^o}me},
  journal = {INRIA},
  volume  = {3},
  pages   = {42}
}

@article{AUDEBAUD2009568,
  title    = {Proofs of randomized algorithms in Coq},
  journal  = {Science of Computer Programming},
  volume   = {74},
  number   = {8},
  pages    = {568-589},
  year     = {2009},
  note     = {Special Issue on Mathematics of Program Construction (MPC 2006)},
  issn     = {0167-6423},
  doi      = {https://doi.org/10.1016/j.scico.2007.09.002},
  url      = {https://www.sciencedirect.com/science/article/pii/S0167642309000240},
  author   = {Philippe Audebaud and Christine Paulin-Mohring},
  keywords = {Randomized algorithms, Proof of partial and total correctness, Functional language, Axiomatic semantics, Probability framing, Call-by-value, Monadic interpretation},
  abstract = {Randomized algorithms are widely used for finding efficiently approximated solutions to complex problems, for instance primality testing and for obtaining good average behavior. Proving properties of such algorithms requires subtle reasoning both on algorithmic and probabilistic aspects of programs. Thus, providing tools for the mechanization of reasoning is an important issue. This paper presents a new method for proving properties of randomized algorithms in a proof assistant based on higher-order logic. It is based on the monadic interpretation of randomized programs as probabilistic distributions (Giry, Ramsey and Pfeffer). It does not require the definition of an operational semantics for the language nor the development of a complex formalization of measure theory. Instead it uses functional and algebraic properties of unit interval. Using this model, we show the validity of general rules for estimating the probability for a randomized algorithm to satisfy specified properties. This approach addresses only discrete distributions and gives rules for analyzing general recursive functions. We apply this theory to the formal proof of a program implementing a Bernoulli distribution from a coin flip and to the (partial) termination of several programs. All the theories and results presented in this paper have been fully formalized and proved in the Coq proof assistant.}
}

@phdthesis{tassarotti2017verifying,
  title  = {Verifying concurrent randomized algorithms},
  author = {Tassarotti, Joseph},
  year   = {2017},
  school = {Carnegie Mellon University Pittsburgh, PA}
}

@inproceedings{10.1007/978-3-319-46750-4_5,
  author    = {Fontaine, Allyx
and Zemmari, Akka},
  editor    = {Sampaio, Augusto
and Wang, Farn},
  title     = {Certified Impossibility Results and Analyses in Coq of Some Randomised Distributed Algorithms},
  booktitle = {Theoretical Aspects of Computing -- ICTAC 2016},
  year      = {2016},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {69--81},
  abstract  = {Randomised algorithms are generally simple to formulate. However, their analysis can become very complex, especially in the field of distributed computing. In this paper, we formally model in Coq a class of randomised distributed algorithms. We develop some tools to help proving impossibility results about classical problems and analysing this class of algorithms. As case studies, we examine the handshake and maximal matching problems. We show how to use our tools to formally prove properties about algorithms solving those problems.},
  isbn      = {978-3-319-46750-4}
}

@misc{Grigoryants2021,
  author       = {Grigoryants, Sergey},
  title        = {LCS algorithm formal verification},
  year         = {2021},
  publisher    = {GitHub},
  journal      = {GitHub repository},
  howpublished = {\url{https://github.com/isergeyam/coq-bigO/blob/main/examples/proofs/Lcs_flat_proof.v}}
}

@incollection{CIC,
  title       = {{Introduction to the Calculus of Inductive Constructions}},
  author      = {Paulin-Mohring, Christine},
  url         = {https://hal.inria.fr/hal-01094195},
  booktitle   = {{All about Proofs, Proofs for All}},
  editor      = {Bruno Woltzenlogel Paleo and David Delahaye},
  publisher   = {{College Publications}},
  series      = {Studies in Logic (Mathematical logic and foundations)},
  volume      = {55},
  year        = {2015},
  month       = Jan,
  keywords    = {Coq proof assistant ; Calculus of Inductive Constructions},
  pdf         = {https://hal.inria.fr/hal-01094195/file/CIC.pdf},
  hal_id      = {hal-01094195},
  hal_version = {v1}
}

@book{ML-lang,
  author    = {Milner, Robin and Tofte, Mads and Macqueen, David},
  title     = {The Definition of Standard ML},
  year      = {1997},
  isbn      = {0262631814},
  publisher = {MIT Press},
  address   = {Cambridge, MA, USA},
  abstract  = {From the Publisher:Standard ML is general-purpose programming language designed for large projects. This book provides a formal definition of Standard ML for the benefit of all concerned with the language, including users and implementers. Because computer programs are increasingly required to withstand rigorous analysis, it is all the more important that the language in which they are written be defined with full rigor. The authors have defined their semantic objects in mathematical notation that is completely independent of Standard ML.}
}

@article{CalculusOfConstructions,
  title   = {The calculus of constructions},
  journal = {Information and Computation},
  volume  = {76},
  number  = {2},
  pages   = {95-120},
  year    = {1988},
  issn    = {0890-5401},
  doi     = {https://doi.org/10.1016/0890-5401(88)90005-3},
  url     = {https://www.sciencedirect.com/science/article/pii/0890540188900053},
  author  = {Thierry Coquand and Gérard Huet}
}

@book{PTS,
  author    = {Pierce, Benjamin C.},
  title     = {Types and Programming Languages},
  year      = {2002},
  isbn      = {0262162091},
  publisher = {The MIT Press},
  edition   = {1st},
  pages     = {466},
  abstract  = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}

@incollection{CurryHowardIsom,
  booktitle = {To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism},
  author    = {William Alvin Howard},
  publisher = {Academic Press},
  title     = {The Formulae-as-Types Notion of Construction},
  editor    = {Haskell Curry and Hindley B. and Seldin J. Roger and P. Jonathan},
  year      = {1980}
}

@article{Hoare,
  author     = {Hoare, C. A. R.},
  title      = {An Axiomatic Basis for Computer Programming},
  year       = {1969},
  issue_date = {Oct. 1969},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {12},
  number     = {10},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/363235.363259},
  doi        = {10.1145/363235.363259},
  abstract   = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.},
  journal    = {Commun. ACM},
  month      = oct,
  pages      = {576–580},
  numpages   = {5},
  keywords   = {programming language design, axiomatic method, theory of programming' proofs of programs, machine-independent programming, program documentation, formal language definition}
}

@inproceedings{SepLogic,
  author    = {Reynolds, J.C.},
  booktitle = {Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},
  title     = {Separation logic: a logic for shared mutable data structures},
  year      = {2002},
  volume    = {},
  number    = {},
  pages     = {55-74},
  doi       = {10.1109/LICS.2002.1029817}
}

@article{CFML,
  author     = {Chargu\'{e}raud, Arthur},
  title      = {Separation Logic for Sequential Programs (Functional Pearl)},
  year       = {2020},
  issue_date = {August 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3408998},
  doi        = {10.1145/3408998},
  abstract   = {This paper presents a simple mechanized formalization of Separation Logic for sequential programs. This formalization is aimed for teaching the ideas of Separation Logic, including its soundness proof and its recent enhancements. The formalization serves as support for a course that follows the style of the successful Software Foundations series, with all the statement and proofs formalized in Coq. This course only assumes basic knowledge of lambda-calculus, semantics and logics, and therefore should be accessible to a broad audience.},
  journal    = {Proc. ACM Program. Lang.},
  month      = aug,
  articleno  = {116},
  numpages   = {34},
  keywords   = {Separation Logic, Program verification, Coq}
}

@inproceedings{SepLogicTime,
  author    = {Atkey, Robert},
  editor    = {Gordon, Andrew D.},
  title     = {Amortised Resource Analysis with Separation Logic},
  booktitle = {Programming Languages and Systems},
  year      = {2010},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {85--103},
  abstract  = {Type-based amortised resource analysis following Hofmann and Jost---where resources are associated with individual elements of data structures and doled out to the programmer under a linear typing discipline---have been successful in providing concrete resource bounds for functional programs, with good support for inference. In this work we translate the idea of amortised resource analysis to imperative languages by embedding a logic of resources, based on Bunched Implications, within Separation Logic. The Separation Logic component allows us to assert the presence and shape of mutable data structures on the heap, while the resource component allows us to state the resources associated with each member of the structure.},
  isbn      = {978-3-642-11957-6}
}
