В этой главе мы вкратце изложим принцип работы фреймворка, разработанного Шагеро и др. \cite{base_article}.
\section{Формализация $\mathcal{O}$-нотации}
Первым шагом в построении нужного формализма является формализация $\OO$-нотации. В классическом понимании, когда мы пишем $f = \OO(g)$, то это означает,
что $\exists c\ \exists n\ \forall x \geq n\  |f(x)| \leq c|g(x)|$, причем область значения и область определения обычно предполагаются подмножествами $\RR$.
Стоит сразу отметить, что обозначение $f = \OO(g)$ может запутать, т.к. на самом деле данное отношение не является отношением эквивалентности, а лишь
предпорядком. Поэтому, мы будем придерживаться обозначения $f \preccurlyeq g$, и говорить, что $g$ доминирует $f$.
Нас будут интересовать также и функции многих переменных, поэтому нам нужно рассмотреть обобщение этого понятия. Сразу понятно, что мы можем обобщить область
значений на произвольное нормированное векторное пространство, но в нашей работе нам достаточно будет рассмотреть $\ZZ$, т.к. мы будем оценивать асимптотику программ,
то есть количество шагов.
\section{Фильтры}
Для обобщения области значений, стоит перефразировать определение $\OO$-нотации на естественном языке: существует $c$, такое, что
для любого достаточно большого $x$, $f(x) \leq c|g(x)|$. В таком виде, когда мы видим фразу ''достаточно большой $x$'' или, если сказать по-другому,
''для почти любого $x$'', на ум сразу приходят фильтры множеств, т.к. фильтры как раз инкапсулируют понятие ''больших множеств'' то есть множеств, содержащих
в каком-то смысле ''почти все'' элементы. В результате, мы можем сформулировать следующее определение:
\begin{definition}
	Пусть $A$ -- множество, $\FF$ -- фильтр на нем, $V$ -- нормированное векторное пространство. Пусть $f, g: A \to V$. Тогда, будем говорить, что
	$f$ доминируется $g$($f \preccurlyeq g$), если $\{x: |f(x)| \leq c|g(x)|\} \in \FF$.
\end{definition}
Из этого определения понятно, что для задания предпорядка доминирования необходимо задать фильтр на соответствующем множестве. Мы будем обозначать
получившееся отношение как $\preccurlyeq_{\FF}$, и опускать $\FF$, когда он понятен из контекста. \\
Для реализации этого определения в Coq, нам нужно cформулировать его на языке теории типов. Пусть $A$ -- это тип. Тогда, т.к. $\FF$ в случае фильтра на
множестве $A$ является подмножеством $2^{A}$, то есть элементом $\FF \in 2^{2^{A}}$, то если $A$ -- это тип, то $\FF$ имеет тип $\PP(\PP(A))$, где
$\PP(A) = A \to \text{Prop}$. Переведем теперь определение фильтра на язык теории типов. Для начала запишем его на языке теории множеств.
\begin{definition}
	Пусть $A$ -- множество. Тогда $\FF \in 2^{2^{A}}$ -- фильтр на $A$, если выполняются следующие условия:
	\begin{enumerate}
		\item $\FF \neq \varnothing$
		\item $\varnothing \notin \FF$
		\item $\forall X,Y \in \FF,\ X \cap Y \in \FF$
		\item $\forall X \in \FF,\ \forall Y \supseteq X,\ Y \in \FF$
	\end{enumerate}
\end{definition}
Теперь переведем его на язык теории типов. Для начала введем обозначение. Пусть $A$ -- тип, $P: A \to Prop$ -- предикат, и $\UU: \PP(\PP(A)) = A \to (A \to Prop)$.
Тогда положим $\UU x.P = \UU (\Pi_{x: A} P x): Prop$ -- утверждение о том, что \\ $P$ выполняется на множестве из $\UU$. Теперь мы готовы сформулировать
определения фильтра в теории типов.
\begin{definition}
	Пусть $A$ -- тип. Тогда $\FF: \PP(\PP(A))$ -- фильтр на $A$, если
	\begin{enumerate}
		\item $\left(P_{1} \Rightarrow P_{2}\right) \Rightarrow \mathbb{U} x . P_{1} \Rightarrow \mathbb{U} x . P_{2}$
		\item $\mathbb{U} x . P_{1} \wedge \mathbb{U} x . P_{2} \Rightarrow \mathbb{U} x .\left(P_{1} \wedge P_{2}\right)$
		\item $\mathbb{U} x . \text { True }$
		\item $\mathbb{U} x . P \Rightarrow \exists x . P$
	\end{enumerate}
\end{definition}
\section{Примеры фильтров}
На любом ЧУМ $(A, \leq)$, в котором у любых двух элементов существует верхняя грань, можно задать фильтр, порожденный данным порядком.
\begin{definition}
	Пусть $(A, \leq)$ -- ЧУМ, в котором у любых двух элементов существует верхняя грань.
	Тогда $\FF = \{Q \subseteq A: \exists x_0 \forall x \geq x_0\ x \in Q\}$ -- фильтр на $A$.
\end{definition}
Заметим сразу, что стандартный порядок на $\ZZ, \NN, \RR$ порождает фильтр,
относительно которого отношение доминирования совпадает с классическим определением доминирования.
\par
Вспомним, что мы хотели построить обобщение отношения доминирования для того, чтобы перевести его на функции многих переменных. Это делается с помощью произведения
фильтров. Существует несколько определений произведения фильтров. Мы будем пользоваться следующим.
\begin{definition}
	Пусть $\FF_1, \FF_2$ -- фильтры на множествах $A_1, A_2$ соответственно. Тогда,
	$\FF = \FF_1 \times \FF_2 = \{Q \subseteq A_1 \times A_2: \exists Q_1 \in \FF_1, Q_2 \in \FF_2,\ Q_1 \times Q_2 \subseteq Q\}$ -- фильтр на $A_1 \times A_2$.
\end{definition}
С помощью этой конструкции, мы получаем фильтр, а следовательно и предпорядок доминирования на $\NN^k, \ZZ^k, \RR^k$ и т.д.
Например, если взять стандартный фильтр на ЧУМе $(A, \leq)$, и рассмотреть его квадрат как фильтр на $A^2$, то мы получим следующее отношение доминирования
на функциях $f, g: A^2 \to Z$:\\
$f \preccurlyeq g \iff \exists c \in \NN, a_0, b_0 \in A:\ \forall a \geq a_0, b \geq b_0\ |f(a, b)| \leq c|g(a, b)|$. \\
Именно этим определением доминирования на $\ZZ^2$ мы будем пользоваться при доказательстве нашего результата.
\section{Свойства отношения доминирования}
Для доказательства утверждений о доминировании функций, нам нужны будут свойства этого отношения.
В первую очередь, сформулируем утверждение о сохранении доминирования при суммировании функций.
\begin{lemma}\label{lemma:sum}
	Пусть $f, g, h: A \to Z$, $\FF$ -- фильтр на $A$. Тогда, $f \preccurlyeq h \land g \preccurlyeq h \implies (f + g) \preccurlyeq h$.
\end{lemma}
Следующая лемма позволяет нам сводить сумму к максимуму и наоборот.
\begin{lemma}\label{lemma:sum_max}
	Пусть $f, g: A \to Z$, $\FF$ -- фильтр на $A$. Тогда, если $\FF x. f(x) \geq 0 \land \FF x. g(x) \geq 0$, то
	$\max(f, g) \preccurlyeq (f + g) \land (f+g) \preccurlyeq \max(f, g)$.
\end{lemma}
Следующая лемма позволяет нам доказывать утверждения о доминировании произведения функций.
\begin{lemma}\label{lemma:prod}
	Пусть $f_1, g_1, f_2, g_2: A \to Z$, $\FF$ -- фильтр на $A$. Тогда,\\
	$f_1 \preccurlyeq g_1 \land f_2 \preccurlyeq g_2 \implies f_1f_2 \preccurlyeq g_1g_2$.
\end{lemma}
Следующая лемма позволяет доказывать утверждения о доминировании кумулятивных сумм, которые возникают в циклах.
\begin{lemma}\label{lemma:cumul}
	Пусть $f, g: A \times Z \to Z$, $\FF$ -- фильтр на $A$, $\UU$ -- стандартный фильтр на $\ZZ$, $i_0 \in \ZZ$. Тогда, при следующих условиях
	\begin{enumerate}
		\item $\FF x. \forall i \geq i_0\ f(a, i) \geq 0$
		\item $\FF x. \forall i \geq i_0\ g(a, i) \geq 0$
		\item $\forall a \in A, f_a(i) = f(a, i)$ -- не убывает на $[i_0;\infty]$
	\end{enumerate}
	выполняется, что если $f \preccurlyeq_{\FF \times \UU} g$, то $f^* \preccurlyeq_{\FF \times \UU} g^*$, где $f^*(a, n) = \sum_{i=i_{0}}^{n} f(a, i)$.
\end{lemma}
\section{Формализация спецификации}
Итак, в процессе рассуждений выше, нам стало понятно, что нужно для формальной записи спецификации программы:
\begin{itemize}
	\item Множество, на котором определена функция стоимости(обозначим его за $A$).
	\item порядок на $A$, который генерирует соответствующий фильтр.
	\item Функция доминирования стоимости.
	\item Само утверждение спецификации, которое говорит о том, что данная программа выполняется за выданное время и дает корректный выход.
\end{itemize}
Для этого набора в \cite{base_article} был введен специальный тип $\text{specO}$:

\begin{figure}[H]
	\caption{Определение specO}
	\label{code:specO}
	\begin{minted}{coq}
Record specO
       (A : filterType) (le : A -> A -> Prop)
       (spec : (A -> Z) -> Prop)
       (bound : A -> Z) :=
  SpecO {
      cost : A -> Z;
      spec : spec cost;
      cost_nonneg : forall x, 0 <= cost x;
      cost_monotonic : monotonic le Z.le cost;
      cost_dominated : dominated A cost bound
    }.
  \end{minted}
\end{figure}
В этих обозначениях, $A$ -- множество, на котором определена функция стоимости, $\text{le}$ -- порядок на $A$, $\text{spec}$ --
тройка в Сепарационной Логике, утверждающая о корректности программы, а также о том, что она выполняется за время $\text{cost}$,
$\text{bound}$ -- функция доминирования стоимости. Мы видим, что от функции стоимости также требуется неотрицательность и монотонность.
В \cite{base_article} показано, почему эти условия необходимы. Давайте рассмотрим это утверждение на конкретном примере.
Пусть $\text{length}$ -- функция, вычисляющая длину списка за $\mathcal{O}(n)$. Тогда, спецификация будет выглядеть следующим образом:

\begin{figure}[H]
	\caption{Спецификация length}
	\label{code:length_spec}
	\begin{minted}{coq}
Theorem length_spec:
	specO Z_filterType Z.le  (fun cost ->
	forall A (l:list A), triple (length l)
	PRE ($ (cost |l|))
	POST (fun y -> [ y = |l| ]))
	(fun n -> n)
  \end{minted}
\end{figure}

Написанное выше означает, что рассматривается $\ZZ$ со стандартным фильтром на нем, и функция доминирования стоимости -- $f(n) = n$. Это означает, что
для реальной функции стоимости $\text{cost}$ выполняется $\text{cost} = \mathcal{O}(n)$.