В этой главе мы дадим все формальные определения и формулировки, чтобы объяснить, на чем основана теория, разработанная в \cite{base_article},
а также интерактивное программное средство доказательства теорем Coq \cite{the_coq_development_team_2021_4501022}, на котором эта теория построена.
Мы начнем с лямбда-исчисления \cite{rojas2015tutorial}.
\section{Лямбда-исчисление}
Лямбда исчисления возникло в работе Алонзо Черча по основаниям математики \cite{Church01}. В ней он пытался предложить формальную систему,
в которой можно было бы избежать стандартных парадоксов наивной теории множеств \cite{Miller_ahistorical}. Позднее было обнаружено, что
предложенная система также является противоречивой  \cite{Kleene01}. После этого, Черч опубликовал часть этой системы, отвечающую за вычислимость
\cite{Church02}, а позднее и исправленную полноценную формальную систему, известную как "просто типизированное лямбда-исчисление" \cite{Church03}.
В этой главе мы рассмотрим само лямбда-исчисление, то есть систему, рассмотренную в \cite{Church02}.
\subsection{Формальное определение}
Лямбда-исчисление, есть не что иное, как простая семантика вычислимости. Оно позволяет довольно просто оперировать вычислимыми функциями.
Для описания лямбда исчисления будет использован следующий язык:
\begin{itemize}
  \item переменные обозначаются буквами латинского алфавита -- $x,y,z,\ldots$. Множество всех переменных обозначим за $\mathcal{V}$.
  \item символ абстракции $\lambda$ и точка "$.$".
  \item Скобки $"("$ и $")"$.
\end{itemize}
Тогда, мы можем индуктивно построить множество лямбда-выражений $\Lambda$ по слндующим правилам:
\begin{itemize}
  \item $x \in \mathcal{V} \implies x \in \Lambda$.
  \item $x \in \mathcal{V} \land M \in \Lambda \implies (\lambda x . M) \in \Lambda$.
  \item $M \in \Lambda \land N \in \Lambda \implies (M N) \in \Lambda$.
\end{itemize}
Второе правило обычно называется лямбда-абстракцией, а третье -- аппликацией.
Лямбда-выражения также обычно называют лямбда-термами или просто термами. \\
Далее, зададим индуктивно множество свободных переменных $FV(N) \subset \mathcal{V}$ данного лямбда-выражения $N \in \Lambda$
следующим образом:
\begin{itemize}
  \item $x \in \mathcal{V} \implies FV(x) = \{x\}$.
  \item $x \in \mathcal{V} \land M \in \Lambda \implies FV(\lambda x . M) = FV(M) \setminus \{x\}$.
  \item $M \in \Lambda \land N \in \Lambda \implies FV(M N) = FV(M) \cup FV(N)$.
\end{itemize}
Переменные, не являющиеся свободными, называются связанными. \\
Теперь мы готовы определить замену переменной $x \in \mathcal{V}$ на терм $N \in \Lambda$ в терме $M \in \Lambda$,
получая при этом новый терм $M[x := N] \in \Lambda$ следующим образом:
\begin{itemize}
  \item $x[x := N] = N$.
  \item $y \in \mathcal{V} \land x \neq y \implies y[x := N] = y$.
  \item $(M_1 M_2)[x := N] = (M_1[x := N] M_2[x := N])$.
  \item $(\lambda x . M)[x := N] = \lambda x . M$.
  \item $y \neq x \land y \not \in FV(N) \implies (\lambda y . M)[x := N] = \lambda y . (M[x := N])$.
\end{itemize}
Стоит отметить, что замена связанных переменных не производится (правило 4). Действительно, ведь лямбда-абстракция работает
только с переменными, а не с произвольными термами. Также стоит отметить то, что замена не может производиться, если
в текущем терме присутствует переменная, которая также имеет свободное вхождение в предлагаемую замену
(условие $y \not \in FV(N)$ в правиле 5). Действительно, иначе $(\lambda x . y)[x := y] = \lambda y . y$, но совершенно ясно, что
после простого переименования переменной $x$ в $y$(это называется $\alpha$-конверсия) смысл терма полностью поменялся. \\
После этих определений мы готовы ввести основные операции над лямбда-термами. Выделяют три операции:
\begin{itemize}
  \item $\alpha$-конверсия -- это просто переименование переменной.
        То есть, применяя $\alpha$-конверсию к терму $M \in \Lambda$, заменяя $x$ на $y$, мы получаем $M[x := y]$.
  \item $\beta$-редукция -- это преобразование, которое реализует применение функции в обычном понимании. Формально $\beta$-редукция
        применима к терму вида $(\lambda x . M) N$, и выдает терм $M[x := N]$.
  \item $\eta$-редукция -- это преобразование, которое реализует идею так называемой functional extensionality. Смысл этого утверждения
        в том, что функцию полностью определяют ее значения на всех входах. Формально, $\eta$-редукция конвертирует
        $\lambda x . f x$ в $f$, если $x \not \in FV(f)$.
\end{itemize}
Условие $x \not \in FV(f)$ в $\eta$-редукции существенно, иначе мы могли бы свести $\lambda x . xx$ к $x$.


\subsection{Нормальная форма}
После того, как мы определили лямбда-термы и преобразования над ними, сразу встает вопрос -- существует ли некая каноническая форма
для каждого терма, к которой можно свести этот терм данными преобразованиями? Обычно, каноническим термом считается такой терм,
к которому больше нельзя применить никаких преобразований. Такие термы называются нормальными. Ясно, что если мы будем
рассматривать $\alpha$-конверсию, то нормальных термов не существует, так что мы будем рассматривать только $\beta \eta$-конверсии.
Формальные системы обладают свойством
сильной нормализации, если применение любых доступных преобразований к любому терму за конечное число шагов выдает нормальный терм.
Если же для каждого терма просто существует последовательность преобразований, после которой терм становится нормальным, то такая
система обладает свойством слабой нормализации. На самом деле, лямбда-исчисление не обладает даже свойством слабой нормализации.
Действительно, рассмотрим терм $(\lambda x . xxx)(\lambda x . xxx)$. Заметим, что мы здесь можем применить лишь $\beta$-редукцию,
получая $(\lambda x . xxx)(\lambda x . xxx)(\lambda x . xxx)$. Здесь, опять, можно применить только $\beta$-редукцию, получив
$(\lambda x . xxx)(\lambda x . xxx)(\lambda x . xxx)(\lambda x . xxx)$, и т.д. Очевидно, что у этого терма просто
нет никакой нормальной формы. Тем не менее, верно следующее утверждение, называемое теоремой Черча-Россера:
\begin{theorem}[Черча-Россера, \cite{MR1501858}]
  $\forall M, N_1, N_2 \in \Lambda, M \rightarrow_{\beta \eta} N_1 \land M \rightarrow_{\beta \eta} N_2 \implies
    \exists X \in \Lambda, N_1 \rightarrow_{\beta \eta} X \land N_2 \rightarrow_{\beta \eta} X$.
\end{theorem}
Здесь $\rightarrow_{\beta \eta}$ -- рефлексивное, транзитивное замыкание $\beta$ и $\eta$ редукции.
Из этой теоремы следует, в частности, что нормальная форма единственна (по модулю $\alpha$-конверсии), если она существует.
На самом деле тот факт, что лямбда-исчисление не обладает свойствами нормальности, как раз позволяем выразить в этом исчислении
все вычислимые функции. Т.к. любая система, обладающая этими свойствами, Тьюринг-полной уже являться не может \cite{Church03}.
Далее мы будем рассматривать лямбда-термы с точностью до эквивалентности по преобразованием. Формально, мы рассматриваем фактор-множество
$\Lambda$ по отношению эквивалентности -- транзитивному, симметричному и рефликсивному замыканию $\alpha, \beta, \eta$-конверсий.
Далее, приступим к выражению примитивов вычислимости с помощью \textlambda-термов. Мы будем выражать их с помощью т.н.
комбинаторов -- замкнутых \textlambda-термов.

\subsection{Арифметика}
Числа в лямбда-исчислении моделируются с помощью так называемых нумералов Черча. Формально, определим:
\begin{itemize}
  \item $\numeral{0} = \lambda f x . x$
  \item $\numeral{1} = \lambda f x . fx$
  \item $\numeral{2} = \lambda f x . ffx$
  \item $\numeral{n} = \lambda f x . f^nx$
\end{itemize}
То есть, число $n$ моделируется аппликацией функции $n$ раз. Выразим, например функцию следующего элемента $\combinator{succ}$:
$$\combinator{succ} = \lambda nfx . f (n f x)$$
Ясно, что $\forall n \in \mathbb{N}\ \combinator{succ}\ \numeral{n} = \numeral{n + 1}$. В этом смысле $\lambda$-терм
$\combinator{succ}$ выражает функцию следующего элемента. Подобным образом мы можем выразить и другие арифметические операции:
\begin{itemize}
  \item $\combinator{plus} = \lambda m n f x . m (n f x)$
  \item $\combinator{mult} = \lambda m n f . m (n f)$
  \item $\combinator{exp} = \lambda m n . n m$
\end{itemize}

\subsection{Логика}
Определим, что мы будем называть истиной и ложью в лямбда-исчислении:
\begin{itemize}
  \item $\combinator{true} = \lambda x y . x$
  \item $\combinator{false} = \lambda x y . y$
\end{itemize}
В этих терминах несложно выразить основные логические функции:
\begin{itemize}
  \item $\combinator{and} = \lambda p q . p q p$
  \item $\combinator{or} = \lambda p q . p p q$
  \item $\combinator{not} = \lambda p . p\ \combinator{false}\ \combinator{true}$
\end{itemize}
Это логические функции в том смысле, что их поведение на термах $\combinator{true}$ и $\combinator{false}$ соответствуют таблице истинности.
Т.е. $\combinator{and}\ \combinator{true}\ \combinator{false} = \combinator{false}$,
$\combinator{and}\ \combinator{true}\ \combinator{true} = \combinator{true}$ и т.д.

\subsection{Пары и трюк Клини}
Введем формализм для кодирования пар элементов:
\begin{itemize}
  \item $\combinator{pair} = \lambda x y f . f x y$
  \item $\combinator{first} = \lambda p . p\ \combinator{true}$
  \item $\combinator{second} = \lambda p . p\ \combinator{false}$
\end{itemize}
Трюк Клини заключается в построении  функционала $\combinator{K}$ на парах, который работает следующим образом
$(x,y) \xmapsto{\combinator{K}} (f(x), x)$ для каких-то фиксированных $f, x, y$. Теперь ясно как его выразить:
$$ \combinator{K} = \lambda f p . \combinator{pair}\ (f(\combinator{first}\ p))\ (\combinator{first}\ p)$$
Трюк Клини является очень полезным приемом для построения комбинаторов. Выразим через него например комбинатор
$\operatorname{pre}: \NN \to \NN$,
$$
  \operatorname{pre}(n) =
  \begin{cases}
    n-1,\quad n > 0 \\
    0,\quad n = 0
  \end{cases}
$$
Обозначим искомый комбинатор за $\combinator{pre}$.
Заметим, что $(\combinator{PRE}\ n)$ есть не что иное, как применение $(\combinator{K}\ \combinator{succ})$ $n$ раз к паре $(0, 0)$ и взятия второго элемента пары:
$$ \combinator{pre} =  \lambda n . \combinator{second}\ (n\ (\combinator{K}\ \combinator{succ})\ (\combinator{pair}\ \numeral{0}\ \numeral{0}))$$.


\subsection{Рекурсия}
Очень важным приемом в \textlambda-исчислении является реализация рекурсии. Разберем ее на примере реализации факториала.
Для начала научимся сравнивать с нулем:
$$
  \combinator{iszero} = \lambda n . n\ (\lambda x . \combinator{false})\ \combinator{true}
$$
Здесь мы используем числа как аппликацию функции. Вспомним теперь рекурсивное определение факториала:
$$
  n! =
  \begin{cases}
    n \times (n-1)!,\quad n > 0 \\
    1,\quad n = 0
  \end{cases}
$$
Тогда, комбинатор $\combinator{fact}$ можно выразить просто следующим образом:
$$\combinator{fact} = \lambda n . (\combinator{iszero}\ n)\ \numeral{1}\ (\combinator{mult}\ n\ (\combinator{fact}(\combinator{pre}\ n)))$$
Проблема этого определения в том, что $\combinator{fact}$ находится в обоих частях равенства,
и это формально некорректнеое определение в \textlambda-исчислении. Но здесь нам приходит на помощь еще один трюк. Рассмотрим следующий функционал:
$$\combinator{fact'} = \lambda g n . (\combinator{iszero}\ n)\ \numeral{1}\ (\combinator{mult}\ n\ (g(\combinator{pre}\ n))) $$
Тогда заметим следующий (чисто синтаксический, на первый взгляд) факт:
$$ \combinator{fact} = \combinator{fact'}\ \combinator{fact} $$
Получается, что искомый комбинатор $\combinator{fact}$ суть неподвижная точка $\combinator{fact'}$. Тогда, нам осталось предъявить комбинатор, выражающий
неподвижную точку данного. То есть такой комбинатор $\combinator{Y}$, что для любого другого комбинатора $\combinator{F}$, верно
$$\combinator{Y}\ \combinator{F} = \combinator{F}(\combinator{Y}\ \combinator{F})$$
Мы можем предъявить один из таких комбинаторов \cite{engeler_1984}:
$$ \combinator{Y} = \lambda g . (\lambda x . g (x\ x))(\lambda x . g (x\ x))$$
Докажем это:
\begin{eqnarray*}
  && Y F \\
  & \equiv & (\lambda g . (\lambda x . g (x\ x))(\lambda x . g (x\ x))) F \\
  & \to_\beta & (\lambda x . F (x\ x))(\lambda x . F (x\ x)) \\
  & \to_\beta & F ((\lambda x . F (x\ x))(\lambda x . F (x\ x))) \\
  & \equiv & F (Y F)
\end{eqnarray*}
Итого, используя $\combinator{Y}$, получаем
$$ \combinator{fact} = \combinator{Y}\ \combinator{fact'}$$
Описанная выше схема позволяет нам выражать любые рекурсивные функции.

\subsection{Тьюринг-полнота}
Для доказательства полноты \textlambda-исчисления нужно реализовать машину Тьюринга на этом языке. Классическим способом это сделать является
сведения \textlambda-исчисления к \textmu-рекурсивным функциям, и доказательства уже их полноты. Формальное доказательство можно найти у самого Тьюринга
\cite{Turing01}.

\section{Просто типизированное \textlambda-исчисление}
Данная формальная система также была предложена Алонзо Черчем \cite{Church03}. В ней Черч пытался избежать парадоксальных конструкций 
нетипизированного \textlambda-исчисления. Эта система уже обладает свойством сильной нормализации \cite{Tait01},  
и даже является в каком-то смысле полноценной  логической теорией (то есть имеет место Соответствие Карри — Ховарда, о котором речь пойдет дальше). 
\subsection{Формальное определение}
\begin{itemize}
  \item Типами $\tau$ являются базовые типы из некоторого фиксированного множества B,
        типовые переменные с идентификаторами из множества переменных V\\($B \cap V = \emptyset$),
        а также типы, полученные при помощи применения конструктора типов $\rr$: \\
        $$\tau ::= T\ |\ v\ |\ \tau \rr \tau$$
        здесь T $\in$ B — типы из зафиксированного множества базовых типов, v $\in$ V — типовые переменные,
        идентификаторы которых берутся из некоторого множества V.
  \item Выражениями e являются константы из некоторого зафиксированного множества C,
        переменные, абстракции и аппликации (применения):
        $$e ::= c\ |\ x\ |\ \lambda x : \tau.e\ |\ (e\ e)$$
        здесь $c \in C$ — константы, имеющие базовые типы.
        Константами, являются конкретные значения из базовых типов.
        Например, $True, False \in Bool$, $0, 1 \in Int$ и т. д. \\
        Запись $\lambda x : \tau.e$ обозначает типизированную абстракцию —
        связанная переменная x имеет тип $\tau$.
  \item Контексты типизации представляют собой множества предположений о типизации вида $x : \tau$,
        то есть предположений, что «переменная x имеет тип $\tau$»:
        $$\mathbf{\Gamma}=\left\{x_{i}: \tau_{i}\right\}_{i=1}^{n}$$
  \item Отношение типизации, обозначаемое как $\mathbf{\Gamma} \vdash e: \tau$ обозначает, что выражение
        e имеет тип $\tau$ в контексте $\mathbf{\Gamma}$ и, таким образом, корректно типизировано.
        Конкретизации отношений типизации называются суждениями о типизации.
\end{itemize}
Опишем теперь правила вывода для типов выражений.
\subsection*{Правила вывода типов}
\begin{itemize}
  \item Вывод типа для константы.
        \begin{equation}\frac{c:(T \in B) \in C}{\Gamma \vdash c: T} \vee \frac{c:(v \in V) \in C}{\Gamma \vdash c: v}\end{equation}
  \item Вывод типа для переменной.
        \begin{equation}\frac{x: \tau \in \Gamma}{\Gamma \vdash x: \tau}\label{eq:2}\end{equation}
  \item Вывод типа для абстракции.
        \begin{equation}\frac{\Gamma \cup\{x: \tau\} \vdash e: \sigma}{\Gamma \vdash(\lambda x: \tau . e): \tau \rightarrow \sigma}\label{eq:3}\end{equation}
  \item Вывод типа для аппликации.
        \begin{equation}\frac{\Gamma \vdash e_{1}: \tau \rightarrow \sigma, e_{2}: \tau}{\Gamma \vdash\left(e_{1}\ e_{2}\right): \sigma}\label{eq:4}\end{equation}
\end{itemize}
